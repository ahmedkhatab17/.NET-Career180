namespace LearnItCSD03
{
    internal class Program
    {
        static void Main(string[] args)
        {
            #region Stack V1
            //Stack s1 = new Stack();  ///tos=0
            ////new +class=allocation +initialization
            //s1.Push(10);
            //s1.Push(20);
            //s1.Push(30);
            //s1.Push(40);
            //s1.Push(50);
            //s1.Push(60);
            //s1.Push(70);

            //Console.WriteLine(s1.Pop()); //50
            //Console.WriteLine(s1.Pop());
            //Console.WriteLine(s1.Pop());
            //Console.WriteLine(s1.Pop());
            //Console.WriteLine(s1.Pop());
            //Console.WriteLine(s1.Pop());
            //Console.WriteLine(s1.Pop());
            #endregion

            #region Initialize object v1
            //Complex c1=new Complex();
            //Complex c2=new Complex();
            //Complex c3=new Complex();
            /////new + class=allocation +initlialization
            ////Console.WriteLine(c1.Print());

            //c1.SetReal(3);
            //c2.SetReal(3);
            //c3.SetReal(3);
            //c1.SetImg(4);
            //c2.SetImg(4);
            //c3.SetImg(4);
            #endregion

            #region Initialize object v2
            //Complex c1=new Complex();
            //Complex c2=new Complex();
            //Complex c3=new Complex();

            //c1.Initialize();
            //c2.Initialize(5,6);
            //c3.Initialize(7);
            #endregion

            #region Constructor
            //inside class/struct
            //there is hidden method called constructor

            ///Constuctor:
            ///special method inside class/struct  
            ///generated by CLR 
            ///implicitly exist
            ///calling automatically [WE CANNOT CALL CONSTRUCTOR]
            ///when create object/instance from class/struct
            ///
            ///how to write ctor explicitly?
            ///1-method has same name of class/struct
            ///2-has no return type even void 
            ///3-can be overloaded
            ///4-must be public ->may be private => design pattern  SingleTon
            ///class Draft
            ///{
            /////public Draft()
            /////{}
            /////Draft(int _x)
            /////{}
            ///function(){create object from Draft??}
            ///}
            #endregion

            #region Initialize object v3
            //Complex c1= new Complex(); 
            //Complex c2= new Complex(5,6); 
            //Complex c3 = new Complex(7);
            //Console.WriteLine(c1.Print());
            //Console.WriteLine(c2.Print());
            //Console.WriteLine(c3.Print());
            #endregion

            #region Default Argument
            ////public int Add(int x,int y=0 ,int z=0)
            //Draft obj=new Draft();
            ////Console.WriteLine(obj.Add(3,4,5)); //12
            ////Console.WriteLine(obj.Add(3,4)); //7
            ////Console.WriteLine(obj.Add(3)); //3
            ////Console.WriteLine(obj.Add()); //compile error
            ////Console.WriteLine(obj.Add(3,4));

            /////you cannot create overloaded functions
            /////beside default arguments
            #endregion

            #region Stack V2
            //Stack s1 = new Stack();  //size5    tos0  arr||||||
            //Stack s2 = new Stack(10);  //size10 tos0  arr|||||||||||
            //Stack s3 = new Stack(3);  //size3 tos0  arr||||
            #endregion

            #region Static variable/class variable/shared variable
            //member variable inside class with keyword static
            //static variable is variable that O.s will create
            //only one copy of it in heap 
            //regardless # of created objects
            //static variable is alive till app. ends
            //static variable is called by class Name NOT object name
            #endregion

            #region Static 

            //Stack s1 = new Stack();  //size5    tos0  arr||||||
            //Stack s2 = new Stack(10);  //size10 tos0  arr|||||||||||
            //Stack s3 = new Stack(3);  //size3 tos0  arr||||

            ////Console.WriteLine(s1.counter);   //c++,java  cout<<Stack::counter;
            ////c# compile Error not make sense

            ////oop violation
            ////Stack.counter = 22;
            ////Console.WriteLine(Stack.counter);

            ////Console.WriteLine(s1.GetCounter()); //3 //not make sense
            //Console.WriteLine(Stack.GetCounter()); //3 //
            #endregion

            #region calculator
            //int x = 3, y = 5;
            //Console.WriteLine(Draft.Add(x,y));
            //Console.WriteLine(Draft.Pi);

            #endregion

            #region Pass value type by values to function
            //int x = 3;
            //int y = 5;
            //Utility.SwapV(x, y);
            //Console.WriteLine($"x=>{x}"); //3
            //Console.WriteLine($"y=>{y}"); //5
            #endregion

            #region pass value type by Reference
            //int x = 3;
            //int y = 5;
            //Utility.SwapR(ref x,ref y); //pass reference
            //Console.WriteLine($"x=>{x}"); //5
            //Console.WriteLine($"y=>{y}"); //3
            #endregion

            #region PAss Reference Type By value===by reference    [by reference]
            //int[] arr = [1,2,3,4,5];
            //Utility.MultiplyArrayByTen(arr);  //pass reference T by value
            //Console.WriteLine(arr[0]);
            #endregion

            #region out vs. ref
            //int x=3; int y=4; int z;
            //Utility.Add(x, y,out z);
            //Console.WriteLine(z);
            ////somehow to pass by reference unassigned local variable
            ////out -> ref pass by reference + pass unassigned
            #endregion

            #region Parse , convert [search]
            //int x;
            //Console.WriteLine("Enter x");
            //x=int.Parse(Console.ReadLine());
            //x=Convert.ToInt32(Console.ReadLine());
            #endregion

            #region Parse Vs. TryParse
            //int x;
            //Console.WriteLine("Enter x");
            ////x=int.Parse(Console.ReadLine());

            //if (int.TryParse(Console.ReadLine(), out x))
            //{
            //    Console.WriteLine($"x={x}");
            //}
            //else
            //{
            //    Console.WriteLine("Wrong input");
            //}

            //int z;
            //int.TryParse(Console.ReadLine(),out z );



            //int.TryParse(Console.ReadLine(), out int y);
            //Console.WriteLine(y);


            //Utility.Add(33, 44, out int abc);
            //Console.WriteLine(abc);

            #endregion

            #region this
            //////inside any method
            //////there is hidden input parameter called className this
            //Complex c1 = new Complex();
            //c1.SetReal(3); //Compiler  [Complex]SetReal(c1,3)
            ////c1.Initialize();  //compiler [Complex]Initialize(c1);
            #endregion

            #region Create object via named parameter
            //Employee e1=new Employee();
            //Employee e2=new Employee(1,"Sara",22,1234);
            //Console.WriteLine(e1.Print());
            //Console.WriteLine(e2.Print());
            ////Employee e3= new Employee(1,"sara",33,44,5555,77,88888,"A");
            /////with function -> named parameter
            //Employee e3 = 
            //    new Employee(_id:1,_name:"Sara",_age:22,_salary:1233);

            //Employee e4 = 
            //    new Employee(_salary:1234,_name:"Ali",_id:1,_age:22);

            ////MCU -> property
            #endregion

            #region LAb Assignments
            ///1-complete complex class with constructors
            ///2-create dynamic stack [size] with static counter
            ///3-implement queue
            ///
            ////Revise pass by value/by referency
            ////revise out
            ////parse vs convert
            #endregion
        }
    }
}
